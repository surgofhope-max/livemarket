import { HMSAudioTrack } from './HMSAudioTrack';
import { EventBus } from '../../events/EventBus';
import { HMSAudioTrackSettings as IHMSAudioTrackSettings } from '../../interfaces';
import { HMSAudioPlugin, HMSPluginSupportResult } from '../../plugins';
import Room from '../../sdk/models/HMSRoom';
import { TrackAudioLevelMonitor } from '../../utils/track-audio-level-monitor';
import { HMSAudioTrackSettings } from '../settings';
import { HMSLocalStream } from '../streams';
export declare class HMSLocalAudioTrack extends HMSAudioTrack {
    private eventBus;
    private room?;
    private readonly TAG;
    settings: HMSAudioTrackSettings;
    private pluginsManager;
    private processedTrack?;
    private manuallySelectedDeviceId?;
    /**
     * This is to keep track of all the tracks created so far and stop and clear them when creating new tracks to release microphone
     * This is needed because when replaceTrackWith is called before updating native track, there is no way that track is available
     * for you to stop, which leads to the microphone not released even after leave is called.
     */
    private tracksCreated;
    private permissionState?;
    audioLevelMonitor?: TrackAudioLevelMonitor;
    /**
     * see the doc in HMSLocalVideoTrack
     * @internal
     */
    publishedTrackId?: string;
    /**
     * will be false for preview tracks
     */
    isPublished: boolean;
    constructor(stream: HMSLocalStream, track: MediaStreamTrack, source: string, eventBus: EventBus, settings?: HMSAudioTrackSettings, room?: Room | undefined);
    clone(stream: HMSLocalStream): HMSLocalAudioTrack;
    getManuallySelectedDeviceId(): string | undefined;
    resetManuallySelectedDeviceId(): void;
    private handleVisibilityChange;
    /**
     * Replace the new track in stream and update native track
     * @param track
     */
    private updateTrack;
    private replaceTrackWith;
    setEnabled(value: boolean, skipcheck?: boolean): Promise<void>;
    /**
     * verify if the track id being passed is of this track for correlating server messages like audio level
     */
    isPublishedTrackId(trackId: string): boolean;
    setSettings(settings: Partial<IHMSAudioTrackSettings>, internal?: boolean): Promise<void>;
    /**
     * @see HMSAudioPlugin
     */
    getPlugins(): string[];
    /**
     * @see HMSAudioPlugin
     */
    addPlugin(plugin: HMSAudioPlugin): Promise<void>;
    /**
     * @see HMSAudioPlugin
     */
    removePlugin(plugin: HMSAudioPlugin): Promise<void>;
    /**
     * @see HMSAudioPlugin
     */
    validatePlugin(plugin: HMSAudioPlugin): HMSPluginSupportResult;
    /**
     * @internal
     */
    setProcessedTrack(processedTrack?: MediaStreamTrack): Promise<void>;
    initAudioLevelMonitor(): void;
    destroyAudioLevelMonitor(): void;
    cleanup(): Promise<void>;
    /**
     * @internal
     * published track id will be different in case there was some processing done using plugins.
     */
    getTrackIDBeingSent(): string;
    /**
     * @internal
     */
    getTrackBeingSent(): MediaStreamTrack;
    private addTrackEventListeners;
    private removeTrackEventListeners;
    private trackPermissions;
    private handleTrackMute;
    /** @internal */
    handleTrackUnmute: () => Promise<void>;
    private replaceSenderTrack;
    private shouldReacquireTrack;
    private buildNewSettings;
    private handleSettingsChange;
    /**
     * Replace audio track with new track on device change if enabled
     * @param settings - AudioSettings Object constructed with new settings
     * @param internal - whether the change was because of internal sdk call or external client call
     */
    private handleDeviceChange;
}
